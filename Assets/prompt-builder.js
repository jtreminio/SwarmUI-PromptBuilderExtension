"use strict";
// This file is auto-generated by build/generate-assets.js
// Do not edit directly - edit templates/*.html and Assets/prompt-builder.css instead
// HTML Templates
var Templates;
(function (Templates) {
    Templates.danbooruLink = `<a
  href="https://danbooru.donmai.us/wiki_pages/{{encodedTag}}"
  target="_blank"
  class="pb-item-card-link"
  title="View on Danbooru Wiki"
  onclick="event.stopPropagation()"
  >ðŸ”—</a
>
`;
    Templates.error = `<div class="pb-error">
    <strong>Error:</strong> {{errorMessage}}
</div>
`;
    Templates.groupNav = `<ul class="pb-nav-list">
    {{groups}}
</ul>`;
    Templates.group = `<li>
  <div
    class="pb-nav-group {{active}}"
    data-path="{{groupName}}"
    data-group-path="{{groupPath}}"
    data-parent-path=""
  >
    <span class="pb-nav-label">{{groupName}}</span>
  </div>
  {{subgroups}}
</li>
`;
    Templates.itemCard = `<div
  class="pb-item-card {{selected}}"
  data-value="{{value}}"
>
  <span class="pb-item-card-text">{{value}}</span>
  {{link}}
</div>
`;
    Templates.mainContainer = `<div class="pb-prompt-builder-container">
    <div class="pb-nav-panel" id="pb-nav-panel">
        <div class="pb-nav-search-box">
            <input type="text" 
                   class="pb-nav-search-input" 
                   placeholder="Select a category first..." 
                   value="{{searchFilter}}"
                   id="pb-nav-search-input">
        </div>
        <ul id="pb-nav-list" class="pb-nav-list"></ul>
    </div>
    <div class="pb-resize-handle" id="pb-resize-handle"></div>
    <div class="pb-content-panel">
        <div class="pb-selected-tags-container">
            <div class="pb-settings-gear-wrapper">
                <div class="batch-gear-button pb-settings-gear" id="pb-settings-button" title="Settings">&#9881;</div>
            </div>
            <button class="pb-action-button" id="pb-copy-button" title="Copy to clipboard">â¿»</button>
            <button class="pb-action-button" id="pb-clear-button" title="Clear all tags">âœ•</button>
            <button class="pb-action-button" id="pb-retry-button" title="Retry generation">â†»</button>
            {{popoutButton}}
            <div class="pb-selected-tags" id="pb-selected-tags"></div>
        </div>
        <div class="pb-items-container" id="pb-items-container">
            <div class="pb-items-grid"></div>
        </div>
    </div>
</div>
`;
    Templates.noSelection = `<div class="pb-no-selection">
    <h3>Welcome!</h3>
    <p>Select a category from the left panel to view tags</p>
</div>
`;
    Templates.noTagsSelected = `<span class="text-muted">No tags selected</span>`;
    Templates.popoutButton = `<button class="pb-action-button" id="pb-popout-button" title="Pop out to new window">â§‰</button>`;
    Templates.popupWindow = `<!DOCTYPE html>
<html>
  <head>
    <title>Prompt Builder</title>
    {{stylesheets}}
  </head>
  <body>
    <div id="pb-popup-app"></div>
    <script>
      // Store state to restore after script loads
      window.promptBuilderState = {{state}};

      // Make parent window functions available
      window.genericRequest = function(...args) {
          return window.opener.genericRequest(...args);
      };

      // Expose SwarmUI functions from parent window
      if (window.opener.doPopover) {
          window.doPopover = function(...args) {
              return window.opener.doPopover(...args);
          };
      }

      if (window.opener.AdvancedPopover) {
          window.AdvancedPopover = window.opener.AdvancedPopover;
      }
    </script>
    <script src="/ExtensionFile/PromptBuilderExtension/Assets/prompt-builder.js?vary={{timestamp}}"></script>
    <script>
      // After the script loads, initialize with saved state
      window.addEventListener("load", () => {
        if (window.promptBuilderPopupInit) {
          window.promptBuilderPopupInit(window.promptBuilderState);
        }
      });
    </script>
  </body>
</html>
`;
    Templates.settingsModal = `<div class="sui-popover sui_popover_model" id="popover_pb_settings">
    <div class="pb-setting-item" title="Automatically trigger image generation when tags are added">
        <span class="form-check form-switch display-inline-block">
            <input type="checkbox" class="form-check-input" id="pb-setting-autogenerate">
            <label class="form-check-label" for="pb-setting-autogenerate">Auto-generate images</label>
        </span>
    </div>
    <div class="pb-setting-item sui-popover-inline-block" title="Minimum number of tags required before auto-generation triggers">
        <label for="pb-setting-autogenerate-threshold">Min tags:</label>
        <input type="number" id="pb-setting-autogenerate-threshold" class="pb-setting-number-input" min="1" max="20" value="3">
    </div>
    <div class="pb-setting-item" title="Show clickable links to Danbooru wiki for each tag">
        <span class="form-check form-switch display-inline-block">
            <input type="checkbox" class="form-check-input" id="pb-setting-danbooru-links">
            <label class="form-check-label" for="pb-setting-danbooru-links">Show Danbooru links</label>
        </span>
    </div>
    <div class="pb-setting-item" title="Enable console logging for debugging purposes">
        <span class="form-check form-switch display-inline-block">
            <input type="checkbox" class="form-check-input" id="pb-setting-debug-mode">
            <label class="form-check-label" for="pb-setting-debug-mode">Enable debug mode</label>
        </span>
    </div>
</div>

`;
    Templates.subgroup = `<div
  class="pb-nav-subgroup {{depthClass}} {{active}}"
  data-path="{{fullPath}}"
  data-parent-path="{{parentPath}}"
  data-group-path="{{groupPath}}"
>
  {{spacer}}
  <span class="pb-nav-label">{{subgroupName}}</span>
</div>
`;
    Templates.tagChipEditing = `<div
  class="pb-tag-chip pb-tag-chip-editing"
  data-index="{{index}}"
  data-tag="{{tag}}"
>
  <input
    type="text"
    class="pb-tag-chip-input"
    value="{{tag}}"
    data-index="{{index}}"
  />
</div>
`;
    Templates.tagChip = `<div
  class="pb-tag-chip"
  draggable="true"
  data-index="{{index}}"
  data-tag="{{tag}}"
>
  <span>{{tag}}</span>
</div>
`;
})(Templates || (Templates = {}));
// Type definitions for SwarmUI API and global functions
/// <reference path="types.ts" />
/// <reference path="generated-assets.ts" />
class PromptBuilderApp {
    constructor(container) {
        this.data = {};
        this.selectedTags = [];
        this.currentSelection = null;
        this.searchFilter = '';
        this.draggedTagIndex = null;
        this.isDragging = false;
        this.expandedGroups = new Set();
        this.editingTagIndex = null;
        this.hoveredTagIndex = null;
        this.keyboardListenerAttached = false;
        this.DEFAULT_SETTINGS = {
            autoGenerate: false,
            autoGenerateThreshold: 3,
            danbooruLinks: false,
            debugMode: false
        };
        this.container = container;
        this.settings = this.getSettings();
    }
    async init() {
        try {
            await new Promise((resolve, reject) => {
                genericRequest('GetPromptBuilderData', {}, (result) => {
                    if (!result.success) {
                        reject(new Error(result.error || 'Failed to load data'));
                        return;
                    }
                    this.parseData(result.data);
                    resolve();
                }, 0, (error) => {
                    reject(error);
                });
            });
            this.render();
        }
        catch (error) {
            this.container.innerHTML = Templates.error
                .replaceAll('{{errorMessage}}', error.message);
            console.error(error);
        }
    }
    getSettings() {
        const stored = localStorage.getItem('promptBuilderSettings');
        if (stored) {
            try {
                return { ...this.DEFAULT_SETTINGS, ...JSON.parse(stored) };
            }
            catch (e) {
                console.error('Failed to parse settings:', e);
            }
        }
        return { ...this.DEFAULT_SETTINGS };
    }
    parseData(data) {
        for (const [rootKey, rootValue] of Object.entries(data)) {
            this.data[rootKey] = {
                items: [],
                structure: null
            };
            if (Array.isArray(rootValue)) {
                rootValue.forEach((item) => {
                    this.data[rootKey].items.push({
                        value: item,
                        path: [rootKey]
                    });
                });
            }
            else if (typeof rootValue === 'object' && rootValue !== null) {
                this.data[rootKey].structure = this.buildStructure(rootValue, [rootKey]);
                this.extractItems(rootValue, this.data[rootKey].items, [rootKey]);
            }
        }
    }
    buildStructure(obj, parentPath = []) {
        const structure = {};
        for (const [key, value] of Object.entries(obj)) {
            if (key === '_data') {
                continue;
            }
            const currentPath = [...parentPath, key];
            if (Array.isArray(value)) {
                structure[key] = { path: currentPath, hasChildren: false };
            }
            else if (typeof value === 'object' && value !== null) {
                structure[key] = {
                    path: currentPath,
                    hasChildren: true,
                    children: this.buildStructure(value, currentPath)
                };
            }
        }
        return structure;
    }
    extractItems(obj, items, currentPath) {
        for (const [key, value] of Object.entries(obj)) {
            if (key === '_data' && Array.isArray(value)) {
                value.forEach((item) => {
                    items.push({ value: item, path: currentPath });
                });
            }
            else if (Array.isArray(value)) {
                const itemPath = [...currentPath, key];
                value.forEach((item) => {
                    items.push({ value: item, path: itemPath });
                });
            }
            else if (typeof value === 'object' && value !== null) {
                this.extractItems(value, items, [...currentPath, key]);
            }
        }
    }
    render() {
        const isInPopup = window.opener !== null;
        const popoutButton = !isInPopup ? Templates.popoutButton : '';
        this.container.innerHTML = Templates.mainContainer
            .replace('{{searchFilter}}', this.escapeHtml(this.searchFilter))
            .replace('{{popoutButton}}', popoutButton);
        this.container.insertAdjacentHTML('beforeend', Templates.settingsModal);
        this.renderNavigation();
        this.renderSelectedTags();
        this.renderItems();
        this.initializeResize();
        this.attachSearchListener();
        this.attachKeyboardListener();
        if (!isInPopup) {
            this.attachSettingsListeners();
        }
        else {
            // Hide settings button in popup
            const settingsWrapper = document.querySelector('.pb-settings-gear-wrapper');
            if (settingsWrapper) {
                settingsWrapper.style.display = 'none';
            }
        }
        this.getButton('pb-copy-button').addEventListener('click', () => {
            this.copyTagsToClipboard();
        });
        this.getButton('pb-clear-button').addEventListener('click', () => {
            this.clearAllTags();
        });
        this.getButton('pb-retry-button').addEventListener('click', () => {
            this.triggerGeneration();
        });
        if (!isInPopup) {
            this.getButton('pb-popout-button').addEventListener('click', () => {
                this.popOutToWindow();
            });
        }
    }
    attachKeyboardListener() {
        if (this.keyboardListenerAttached) {
            return;
        }
        document.addEventListener('keydown', (e) => {
            // Only respond if hovering over a tag and not currently editing
            if (this.hoveredTagIndex === null || this.editingTagIndex !== null) {
                return;
            }
            const target = e.target;
            // Ignore if user is typing in an input field
            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                return;
            }
            const key = e.key.toLowerCase();
            if (key === 'e') {
                // Edit tag
                e.preventDefault();
                this.editingTagIndex = this.hoveredTagIndex;
                this.renderSelectedTags();
            }
            else if (key === 'd') {
                // Delete tag
                e.preventDefault();
                this.deleteTagAtIndex(this.hoveredTagIndex);
                this.hoveredTagIndex = null;
            }
        });
        this.keyboardListenerAttached = true;
    }
    attachSettingsListeners() {
        const settingsButton = this.getButton('pb-settings-button');
        const popover = document.getElementById('popover_pb_settings');
        if (!settingsButton || !popover) {
            return;
        }
        // Open settings popover using SwarmUI's doPopover
        settingsButton.addEventListener('click', (e) => {
            // Use SwarmUI's built-in popover system if available
            if (typeof doPopover !== 'undefined') {
                doPopover('pb_settings', e);
            }
            this.populateSettingsPopover();
        });
        // Populate initial values
        this.populateSettingsPopover();
        // Auto-save when any setting changes
        const autoGenerateCheckbox = this.getInput('pb-setting-autogenerate');
        const thresholdInput = this.getInput('pb-setting-autogenerate-threshold');
        const danbooruCheckbox = this.getInput('pb-setting-danbooru-links');
        const debugCheckbox = this.getInput('pb-setting-debug-mode');
        autoGenerateCheckbox?.addEventListener('change', () => this.saveSettingsFromPopover());
        thresholdInput?.addEventListener('change', () => this.saveSettingsFromPopover());
        danbooruCheckbox?.addEventListener('change', () => this.saveSettingsFromPopover());
        debugCheckbox?.addEventListener('change', () => this.saveSettingsFromPopover());
    }
    populateSettingsPopover() {
        const autoGenerateCheckbox = this.getInput('pb-setting-autogenerate');
        const thresholdInput = this.getInput('pb-setting-autogenerate-threshold');
        const danbooruCheckbox = this.getInput('pb-setting-danbooru-links');
        const debugCheckbox = this.getInput('pb-setting-debug-mode');
        if (autoGenerateCheckbox) {
            autoGenerateCheckbox.checked = this.settings.autoGenerate;
        }
        if (thresholdInput) {
            thresholdInput.value = String(this.settings.autoGenerateThreshold);
        }
        if (danbooruCheckbox) {
            danbooruCheckbox.checked = this.settings.danbooruLinks;
        }
        if (debugCheckbox) {
            debugCheckbox.checked = this.settings.debugMode;
        }
    }
    saveSettingsFromPopover() {
        const autoGenerateCheckbox = this.getInput('pb-setting-autogenerate');
        const thresholdInput = this.getInput('pb-setting-autogenerate-threshold');
        const danbooruCheckbox = this.getInput('pb-setting-danbooru-links');
        const debugCheckbox = this.getInput('pb-setting-debug-mode');
        const previousDanbooruLinks = this.settings.danbooruLinks;
        this.settings = {
            autoGenerate: autoGenerateCheckbox?.checked ?? this.DEFAULT_SETTINGS.autoGenerate,
            autoGenerateThreshold: Number(thresholdInput?.value ?? this.DEFAULT_SETTINGS.autoGenerateThreshold),
            danbooruLinks: danbooruCheckbox?.checked ?? this.DEFAULT_SETTINGS.danbooruLinks,
            debugMode: debugCheckbox?.checked ?? this.DEFAULT_SETTINGS.debugMode,
        };
        localStorage.setItem('promptBuilderSettings', JSON.stringify(this.settings));
        if (previousDanbooruLinks !== this.settings.danbooruLinks) {
            this.renderItems();
        }
        this.log('Settings saved');
    }
    attachSearchListener() {
        const searchInput = this.getInput('pb-nav-search-input');
        searchInput.addEventListener('input', (e) => {
            this.searchFilter = e.target.value.toLowerCase();
            this.renderItems();
        });
    }
    initializeResize() {
        const resizeHandle = document.getElementById('pb-resize-handle');
        const navPanel = document.getElementById('pb-nav-panel');
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;
        resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startX = e.clientX;
            startWidth = navPanel.offsetWidth;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) {
                return;
            }
            const delta = e.clientX - startX;
            const newWidth = Math.max(200, Math.min(600, startWidth + delta));
            navPanel.style.width = `${newWidth}px`;
        });
        document.addEventListener('mouseup', () => {
            if (!isResizing) {
                return;
            }
            isResizing = false;
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
        });
    }
    renderNavigation() {
        const navPanel = document.getElementById('pb-nav-panel');
        const navList = document.getElementById('pb-nav-list');
        const searchBox = navPanel.querySelector('.pb-nav-search-box');
        const searchInput = searchBox.querySelector('.pb-nav-search-input');
        const previousScrollTop = navList.scrollTop;
        const shouldPreserveFocus = document.activeElement === searchInput;
        const cursorPosition = searchInput.selectionStart;
        let html = '';
        if (!this.data) {
            return;
        }
        for (const [groupName, groupData] of Object.entries(this.data)) {
            const groupPath = groupName;
            const isExpanded = this.expandedGroups.has(groupPath);
            const isActive = this.currentSelection &&
                this.currentSelection.path[0] === groupName &&
                this.currentSelection.path.length === 1;
            let subgroupsHtml = '';
            if (groupData.structure && isExpanded) {
                subgroupsHtml = this.renderSubgroups(groupData.structure, groupName, groupPath);
            }
            html += Templates.group
                .replaceAll('{{active}}', isActive ? 'active' : '')
                .replaceAll('{{groupName}}', groupName)
                .replaceAll('{{groupPath}}', groupPath)
                .replaceAll('{{subgroups}}', subgroupsHtml);
        }
        navList.innerHTML = html;
        const newSearchInput = searchBox.querySelector('.pb-nav-search-input');
        if (this.currentSelection) {
            const breadcrumb = this.currentSelection.path.join(' > ');
            newSearchInput.placeholder = `Search in ${breadcrumb}...`;
        }
        else {
            newSearchInput.placeholder = 'Select a category first...';
        }
        if (shouldPreserveFocus) {
            newSearchInput.focus({ preventScroll: true });
            newSearchInput.setSelectionRange(cursorPosition, cursorPosition);
        }
        navList.scrollTop = previousScrollTop;
        requestAnimationFrame(() => {
            navList.scrollTop = previousScrollTop;
        });
        // Attach click listeners for expansion/collapse and selection
        navPanel.querySelectorAll('[data-group-path]').forEach(el => {
            el.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const element = el;
                const groupPath = element.dataset.groupPath;
                const parentPath = element.dataset.parentPath;
                const path = element.dataset.path.split('>');
                // Not expanded - expand it and collapse siblings
                if (!this.expandedGroups.has(groupPath)) {
                    const siblings = Array.from(this.expandedGroups).filter(p => {
                        // If same parent, it's a sibling
                        if (parentPath === '') {
                            // Root level - siblings are other root groups
                            return !p.includes('>');
                        }
                        else {
                            // Sub level - siblings start with same parent
                            return p.startsWith(parentPath + '>') &&
                                p.split('>').length === groupPath.split('>').length;
                        }
                    });
                    siblings.forEach(s => this.expandedGroups.delete(s));
                    this.expandedGroups.add(groupPath);
                }
                // If this node has only subgroups (no direct items), auto-select the first subgroup
                if (this.nodeHasChildren(path) && !this.nodeHasDirectItems(path)) {
                    const firstChild = this.getFirstChildPath(path);
                    if (firstChild) {
                        this.selectPath(firstChild);
                        return;
                    }
                }
                this.selectPath(path);
            });
        });
        navPanel.querySelectorAll('[data-path]:not([data-group-path])').forEach(el => {
            el.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const element = el;
                const path = element.dataset.path.split('>');
                this.selectPath(path);
            });
        });
    }
    nodeHasChildren(path) {
        if (!path || path.length === 0) {
            return false;
        }
        const root = this.data?.[path[0]];
        if (!root) {
            return false;
        }
        if (path.length === 1) {
            const structure = root.structure;
            return !!structure && Object.keys(structure).length > 0;
        }
        let node;
        let children = root.structure;
        for (let i = 1; i < path.length; i++) {
            if (!children) {
                return false;
            }
            node = children[path[i]];
            if (!node) {
                return false;
            }
            children = node.children;
        }
        return !!node?.hasChildren;
    }
    nodeHasDirectItems(path) {
        if (!path || path.length === 0) {
            return false;
        }
        const groupName = path[0];
        const groupData = this.data?.[groupName];
        if (!groupData) {
            return false;
        }
        for (const item of groupData.items) {
            if (item.path.length !== path.length) {
                continue;
            }
            let matches = true;
            for (let i = 0; i < path.length; i++) {
                if (item.path[i] !== path[i]) {
                    matches = false;
                    break;
                }
            }
            if (matches) {
                return true;
            }
        }
        return false;
    }
    getFirstChildPath(path) {
        const root = this.data?.[path[0]];
        if (!root) {
            return null;
        }
        let children = root.structure;
        if (path.length > 1) {
            for (let i = 1; i < path.length; i++) {
                if (!children)
                    return null;
                const node = children[path[i]];
                if (!node)
                    return null;
                children = node.children;
            }
        }
        if (!children) {
            return null;
        }
        const keys = Object.keys(children);
        if (keys.length === 0) {
            return null;
        }
        return [...path, keys[0]];
    }
    renderSubgroups(structure, groupName, parentPath, depth = 0) {
        let html = '';
        const depthClass = depth === 0
            ? ''
            : depth === 1
                ? 'pb-nav-subgroup-nested'
                : 'pb-nav-subgroup-nested-2';
        for (const [subgroupName, subgroupData] of Object.entries(structure)) {
            const fullPath = subgroupData.path.join('>');
            const isExpanded = this.expandedGroups.has(fullPath);
            const isActive = this.currentSelection &&
                this.currentSelection.path.join('>') === fullPath;
            const hasChildren = subgroupData.hasChildren;
            html += Templates.subgroup
                .replaceAll('{{depthClass}}', depthClass)
                .replaceAll('{{active}}', isActive ? 'active' : '')
                .replaceAll('{{fullPath}}', fullPath)
                .replaceAll('{{parentPath}}', parentPath)
                .replaceAll('{{groupPath}}', hasChildren ? fullPath : '')
                .replaceAll('{{spacer}}', '')
                .replaceAll('{{subgroupName}}', subgroupName);
            if (subgroupData.hasChildren && isExpanded) {
                html += this.renderSubgroups(subgroupData.children, groupName, fullPath, depth + 1);
            }
        }
        return html;
    }
    selectPath(path) {
        this.currentSelection = { path };
        this.searchFilter = '';
        this.renderNavigation();
        this.renderItems();
    }
    renderItems() {
        const container = document.getElementById('pb-items-container').querySelector('.pb-items-grid');
        if (!this.currentSelection) {
            container.innerHTML = Templates.noSelection;
            return;
        }
        const items = this.getItemsForPath(this.currentSelection.path);
        const filtered = this.searchFilter
            ? items.filter(item => item.value.toLowerCase().includes(this.searchFilter))
            : items;
        let html = '';
        filtered.forEach(item => {
            let link = '';
            if (this.settings.danbooruLinks) {
                link = Templates.danbooruLink
                    .replaceAll('{{encodedTag}}', encodeURIComponent(item.value));
            }
            html += Templates.itemCard
                .replaceAll('{{value}}', this.escapeHtml(item.value))
                .replaceAll('{{selected}}', this.selectedTags.includes(item.value) ? 'selected' : '')
                .replaceAll('{{link}}', link);
        });
        container.innerHTML = html;
        container.querySelectorAll('.pb-item-card').forEach(card => {
            card.addEventListener('click', () => {
                const value = card.dataset.value;
                this.toggleTag(value);
            });
            card.addEventListener('mouseenter', () => {
                const el = card;
                if (!el.classList.contains('selected')) {
                    return;
                }
                const value = el.dataset.value;
                if (!value) {
                    return;
                }
                document.querySelectorAll(`.pb-tag-chip[data-tag="${CSS.escape(value)}"]`).forEach(el => {
                    el.classList.add('pb-related-highlight');
                });
            });
            card.addEventListener('mouseleave', () => {
                document.querySelectorAll('.pb-related-highlight').forEach(el => {
                    el.classList.remove('pb-related-highlight');
                });
            });
        });
    }
    getItemsForPath(path) {
        const groupName = path[0];
        const groupData = this.data?.[groupName];
        if (!groupData) {
            return [];
        }
        ;
        return groupData.items.filter(item => {
            if (item.path.length !== path.length)
                return false;
            for (let i = 0; i < path.length; i++) {
                if (item.path[i] !== path[i])
                    return false;
            }
            return true;
        });
    }
    toggleTag(value) {
        this.selectedTags.push(value);
        this.renderSelectedTags();
        this.renderItems();
        this.updatePBPromptField();
        if (this.settings.autoGenerate && this.selectedTags.length >= this.settings.autoGenerateThreshold) {
            this.triggerGeneration();
        }
    }
    deleteTagAtIndex(index) {
        this.selectedTags.splice(index, 1);
        this.renderSelectedTags();
        this.renderItems();
        this.updatePBPromptField();
        if (this.settings.autoGenerate && this.selectedTags.length >= this.settings.autoGenerateThreshold) {
            this.triggerGeneration();
        }
    }
    editTagAtIndex(index, newValue) {
        this.selectedTags[index] = newValue;
        this.renderSelectedTags();
        this.renderItems();
        this.updatePBPromptField();
    }
    // Find or create the hidden input field for pbprompt in the main window
    updatePBPromptField() {
        const targetDocument = this.getMainDocument();
        let pbPromptInput = targetDocument.getElementById('input_pbprompt');
        if (!pbPromptInput) {
            const newInput = targetDocument.createElement('input');
            newInput.type = 'text';
            newInput.id = 'input_pbprompt';
            newInput.style.display = 'none';
            targetDocument.body.appendChild(newInput);
            pbPromptInput = newInput;
        }
        // Set the value to comma-separated tags with escaped parentheses
        const tagsString = this.selectedTags
            .map(tag => tag.replace(/\(/g, '\\(').replace(/\)/g, '\\)'))
            .join(', ');
        pbPromptInput.value = tagsString;
        pbPromptInput.dispatchEvent(new Event('input', { bubbles: true }));
        this.log(`Updated input_pbprompt to: ${tagsString}`);
        // Sync state back to the parent window if we're in a popup
        if (window.opener) {
            try {
                window.opener.postMessage({
                    type: 'PB_SYNC_STATE',
                    payload: {
                        selectedTags: [...this.selectedTags],
                        expandedGroups: Array.from(this.expandedGroups),
                        currentSelection: this.currentSelection
                    }
                }, '*');
            }
            catch (e) {
                console.error('PromptBuilder: Failed to postMessage to parent', e);
            }
        }
    }
    renderSelectedTags() {
        const container = document.getElementById('pb-selected-tags');
        if (this.selectedTags.length === 0) {
            container.innerHTML = Templates.noTagsSelected;
            return;
        }
        container.innerHTML = this.selectedTags.map((tag, index) => {
            if (this.editingTagIndex === index) {
                return Templates.tagChipEditing
                    .replaceAll('{{index}}', String(index))
                    .replaceAll('{{tag}}', this.escapeHtml(tag));
            }
            return Templates.tagChip
                .replaceAll('{{index}}', String(index))
                .replaceAll('{{tag}}', this.escapeHtml(tag));
        }).join('');
        // Handle editing inputs
        container.querySelectorAll('.pb-tag-chip-input').forEach(input => {
            const inputElement = input;
            const index = parseInt(inputElement.dataset.index);
            setTimeout(() => inputElement.focus(), 0);
            inputElement.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const newValue = inputElement.value.trim();
                    if (newValue) {
                        this.editTagAtIndex(index, newValue);
                    }
                    this.editingTagIndex = null;
                    this.renderSelectedTags();
                }
                else if (e.key === 'Escape') {
                    e.preventDefault();
                    this.editingTagIndex = null;
                    this.renderSelectedTags();
                }
            });
            inputElement.addEventListener('blur', () => {
                setTimeout(() => {
                    const newValue = inputElement.value.trim();
                    if (newValue && this.editingTagIndex === index) {
                        this.editTagAtIndex(index, newValue);
                    }
                    this.editingTagIndex = null;
                    this.renderSelectedTags();
                }, 100);
            });
        });
        // Attach drag and right-click event listeners to normal chips
        container.querySelectorAll('.pb-tag-chip:not(.pb-tag-chip-editing)').forEach((chip, index) => {
            const chipElement = chip;
            chipElement.addEventListener('mouseenter', () => {
                this.hoveredTagIndex = index;
            });
            chipElement.addEventListener('mouseleave', () => {
                this.hoveredTagIndex = null;
            });
            chipElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const targetWindow = this.getWindow();
                let contextX = e.clientX;
                let contextY = e.clientY;
                if (typeof targetWindow.mouseX !== 'undefined') {
                    contextX = targetWindow.mouseX;
                    contextY = targetWindow.mouseY;
                }
                const PopoverClass = AdvancedPopover ?? targetWindow.AdvancedPopover ?? window.AdvancedPopover;
                if (!PopoverClass) {
                    console.error('PromptBuilder: Could not find AdvancedPopover');
                    return false;
                }
                const popoverActions = [
                    {
                        key: 'Edit',
                        action: () => {
                            this.editingTagIndex = index;
                            this.renderSelectedTags();
                        }
                    },
                    {
                        key: 'Delete',
                        action: () => {
                            this.deleteTagAtIndex(index);
                        }
                    }
                ];
                return new PopoverClass('tag_context_menu', popoverActions, false, contextX, contextY, document.body, null);
            });
            chipElement.addEventListener('mousedown', (e) => {
                if (e.button === 2) {
                    return;
                }
                ;
                this.isDragging = false;
            });
            chipElement.addEventListener('click', (e) => {
                if (e.button === 2) {
                    return;
                }
                ;
                if (!this.isDragging) {
                    this.deleteTagAtIndex(index);
                }
            });
            chipElement.addEventListener('dragstart', (e) => {
                this.isDragging = true;
                this.draggedTagIndex = index;
                chipElement.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            chipElement.addEventListener('dragend', () => {
                chipElement.classList.remove('dragging');
                this.draggedTagIndex = null;
                container.querySelectorAll('.pb-tag-chip').forEach(c => {
                    c.classList.remove('drag-over-left', 'drag-over-right');
                });
                setTimeout(() => {
                    this.isDragging = false;
                }, 100);
            });
            chipElement.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                if (this.draggedTagIndex !== null && this.draggedTagIndex !== index) {
                    // Determine if mouse is on left or right half of the chip
                    const rect = chipElement.getBoundingClientRect();
                    const midpoint = rect.left + rect.width / 2;
                    const isLeftSide = e.clientX < midpoint;
                    chipElement.classList.remove('drag-over-left', 'drag-over-right');
                    if (isLeftSide) {
                        chipElement.classList.add('drag-over-left');
                    }
                    else {
                        chipElement.classList.add('drag-over-right');
                    }
                }
            });
            chipElement.addEventListener('dragleave', () => {
                chipElement.classList.remove('drag-over-left', 'drag-over-right');
            });
            chipElement.addEventListener('drop', (e) => {
                e.preventDefault();
                if (this.draggedTagIndex !== null && this.draggedTagIndex !== index) {
                    // Determine if drop was on left or right side
                    const rect = chipElement.getBoundingClientRect();
                    const midpoint = rect.left + rect.width / 2;
                    const isLeftSide = e.clientX < midpoint;
                    const draggedTag = this.selectedTags[this.draggedTagIndex];
                    this.selectedTags.splice(this.draggedTagIndex, 1);
                    let newIndex = index;
                    if (this.draggedTagIndex < index) {
                        newIndex--;
                    }
                    if (isLeftSide) {
                        this.selectedTags.splice(newIndex, 0, draggedTag);
                    }
                    else {
                        this.selectedTags.splice(newIndex + 1, 0, draggedTag);
                    }
                    this.renderSelectedTags();
                }
                chipElement.classList.remove('drag-over-left', 'drag-over-right');
            });
        });
    }
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    async copyTagsToClipboard() {
        if (this.selectedTags.length === 0) {
            return;
        }
        try {
            await navigator.clipboard.writeText(this.selectedTags.join(', '));
            const button = this.getButton('pb-copy-button');
            const originalText = button.innerHTML;
            button.innerHTML = 'âœ“';
            button.disabled = true;
            setTimeout(() => {
                button.innerHTML = originalText;
                button.disabled = false;
            }, 2000);
        }
        catch (err) {
            console.error('Failed to copy:', err);
        }
    }
    clearAllTags() {
        this.selectedTags = [];
        this.renderSelectedTags();
        this.renderItems();
        this.updatePBPromptField();
        this.log('Cleared all tags');
    }
    triggerGeneration() {
        const mainDoc = this.getMainDocument();
        const generateButton = mainDoc.getElementById('alt_generate_button');
        if (generateButton) {
            const tagsString = this.selectedTags.join(', ');
            this.log(`Triggering generation with tags: ${tagsString}`);
            generateButton.click();
        }
        else {
            console.error('PromptBuilder: Could not find generate button');
        }
    }
    popOutToWindow() {
        const currentState = {
            selectedTags: [...this.selectedTags],
            expandedGroups: Array.from(this.expandedGroups),
            currentSelection: this.currentSelection ? { ...this.currentSelection } : null
        };
        const popupWindow = window.open('', 'PromptBuilder', 'width=1200,height=800,menubar=no,toolbar=no,location=no,status=no');
        if (!popupWindow) {
            alert('Please allow popups for this site to use the pop-out feature');
            return;
        }
        const stylesheets = Array.from(document.querySelectorAll('link[rel="stylesheet"]'))
            .map(link => link.outerHTML)
            .join('\n');
        const popupHtml = Templates.popupWindow
            .replace('{{timestamp}}', String(Date.now()))
            .replace('{{stylesheets}}', stylesheets)
            .replace('{{state}}', JSON.stringify(currentState));
        popupWindow.document.write(popupHtml);
        popupWindow.document.close();
        this.log('Opened in popup window');
    }
    getWindow() {
        return window.opener || window;
    }
    getMainDocument() {
        return window.opener?.document || document;
    }
    getButton(buttonId) {
        return document.getElementById(buttonId);
    }
    getInput(inputId) {
        return document.getElementById(inputId);
    }
    log(message) {
        if (this.settings.debugMode) {
            console.log('PromptBuilder:', message);
        }
    }
}
class PromptBuilderTool {
    constructor() {
        this.app = null;
        this.mainDiv = null;
    }
    register() {
        this.mainDiv = registerNewTool('prompt_builder', 'Prompt Builder');
        this.mainDiv.addEventListener('tool-opened', () => {
            if (!this.app) {
                this.app = new PromptBuilderApp(this.mainDiv);
                window['promptBuilderApp'] = this.app;
                this.app.init();
            }
        });
    }
}
// Check if we're in a popup window and need to initialize
if (window.opener !== null) {
    // We're in a popup window - set up the popup initialization function
    window.promptBuilderPopupInit = function (savedState) {
        const container = document.getElementById('pb-popup-app');
        const app = new PromptBuilderApp(container);
        if (savedState) {
            app['selectedTags'] = savedState.selectedTags || [];
            app['expandedGroups'] = new Set(savedState.expandedGroups || []);
            app['currentSelection'] = savedState.currentSelection || null;
        }
        window['promptBuilderApp'] = app;
        app.init();
        console.log('PromptBuilder: Initialized in popup window');
    };
}
else if (typeof sessionReadyCallbacks !== 'undefined') {
    // We're in the main SwarmUI context - register as a tool
    sessionReadyCallbacks.push(() => {
        new PromptBuilderTool().register();
    });
    // Register the tab completion
    if (typeof promptTabComplete !== 'undefined') {
        promptTabComplete.registerPrefix('pbprompt', 'Placeholder for the prompt builder', (_prefix) => {
            return [];
        }, true);
    }
    // Listen for popup state sync messages
    window.addEventListener('message', (event) => {
        const data = (event && event.data) || null;
        if (!data || data.type !== 'PB_SYNC_STATE') {
            return;
        }
        const app = window['promptBuilderApp'];
        if (!app) {
            return;
        }
        const payload = data.payload || {};
        app['selectedTags'] = Array.isArray(payload.selectedTags) ? [...payload.selectedTags] : [];
        app['expandedGroups'] = new Set(payload.expandedGroups || []);
        app['currentSelection'] = payload.currentSelection || null;
        // Re-render UI and update hidden field
        app['renderSelectedTags']();
        app['renderItems']();
        app['updatePBPromptField']();
    });
}
//# sourceMappingURL=prompt-builder.js.map